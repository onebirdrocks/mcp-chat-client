"use strict";exports.id=761,exports.ids=[761],exports.modules={26761:(a,b,c)=>{c.d(b,{getMCPClientManager:()=>i});var d=c(3348),e=c(47971),f=c(64077);class g{constructor(a={}){this.connections=new Map,this.reconnectTimers=new Map,this.toolCache=new Map,this.isShuttingDown=!1,this.options={maxReconnectAttempts:a.maxReconnectAttempts??5,reconnectDelay:a.reconnectDelay??2e3,connectionTimeout:a.connectionTimeout??15e3,healthCheckInterval:a.healthCheckInterval??3e4,toolCacheTimeout:a.toolCacheTimeout??6e4},this.startHealthMonitoring(),f.EZ.addWatcher(()=>{this.handleConfigurationChange()})}async initialize(){console.log("Initializing MCP Client Manager...");try{let a=await f.EZ.getConfig(),b=Object.entries(a.mcpServers).map(([a,b])=>({id:a,name:a,command:b.command,args:b.args||[],env:b.env||{},enabled:!b.disabled,timeout:b.timeout,maxConcurrency:b.maxConcurrency}));await this.updateServerConfigs(b),console.log(`MCP Client Manager initialized with ${b.length} server configurations`)}catch(a){throw console.error("Failed to initialize MCP Client Manager:",a),a}}async connectServer(a){if(!a.enabled)return void console.log(`Server ${a.name} is disabled, skipping connection`);let b=this.connections.get(a.id);if(b?.status==="connected")return void console.log(`Server ${a.name} is already connected`);console.log(`Connecting to MCP server: ${a.name} (${a.command} ${a.args?.join(" ")})`);let c={id:a.id,client:null,transport:null,config:{...a,status:"connecting"},tools:[],status:"connecting",reconnectAttempts:b?.reconnectAttempts||0,connectionStartTime:new Date};this.connections.set(a.id,c);try{let b=new d.oQ({command:a.command,args:a.args||[],env:{...process.env,...a.env}}),f=new e.K({name:"mcp-chat-ui",version:"1.0.0"},{capabilities:{tools:{},resources:{},prompts:{}}}),g=new Promise((a,b)=>{setTimeout(()=>{b(Error(`Connection timeout after ${this.options.connectionTimeout}ms`))},this.options.connectionTimeout)});await Promise.race([f.connect(b),g]);let h=await this.discoverTools(f,a.id),i={id:a.id,client:f,transport:b,config:{...a,status:"connected"},tools:h,status:"connected",reconnectAttempts:0,lastError:void 0,lastHealthCheck:new Date,connectionStartTime:c.connectionStartTime};this.connections.set(a.id,i),this.toolCache.set(a.id,{tools:h,timestamp:new Date}),console.log(`Successfully connected to ${a.name} with ${h.length} tools`),this.setupConnectionErrorHandling(i)}catch(e){let b=e instanceof Error?e.message:"Unknown error";console.error(`Failed to connect to ${a.name}:`,b);let d={id:a.id,client:null,transport:null,config:{...a,status:"error"},tools:[],status:"error",lastError:b,reconnectAttempts:c.reconnectAttempts,connectionStartTime:c.connectionStartTime};this.connections.set(a.id,d),a.enabled&&!this.isShuttingDown&&this.scheduleReconnection(a.id)}}async disconnectServer(a){let b=this.connections.get(a);if(!b)return void console.log(`Server ${a} not found`);console.log(`Disconnecting from MCP server: ${b.config.name}`);let c=this.reconnectTimers.get(a);c&&(clearTimeout(c),this.reconnectTimers.delete(a));try{b.client&&"connected"===b.status&&await b.client.close(),b.process&&!b.process.killed&&b.process.kill("SIGTERM")}catch(a){console.error(`Error closing connection to ${b.config.name}:`,a)}b.status="disconnected",b.config.status="disconnected",b.tools=[],b.lastError=void 0,this.toolCache.delete(a),console.log(`Disconnected from ${b.config.name}`)}async reconnectServer(a){let b=this.connections.get(a);if(!b)throw Error(`Server ${a} not found`);console.log(`Reconnecting to MCP server: ${b.config.name}`),await this.disconnectServer(a),b.reconnectAttempts=0,await this.connectServer(b.config)}async discoverTools(a,b){try{let c=(await a.listTools()).tools.map(a=>({name:`${b}.${a.name}`,description:a.description||"",inputSchema:a.inputSchema,serverId:b,category:this.categorizeToolByName(a.name),dangerous:this.isToolDangerous(a.name,a.description),requiresConfirmation:!0}));return console.log(`Discovered ${c.length} tools from ${b}:`,c.map(a=>a.name)),c}catch(a){return console.error(`Failed to discover tools from ${b}:`,a),[]}}getAllTools(){let a=[];for(let b of this.connections.values())if("connected"===b.status){let c=this.toolCache.get(b.id);c&&this.isCacheValid(c.timestamp)?a.push(...c.tools):a.push(...b.tools)}return a}getServerTools(a){let b=this.connections.get(a);if(!b||"connected"!==b.status)return[];let c=this.toolCache.get(a);return c&&this.isCacheValid(c.timestamp)?c.tools:b.tools}async executeTool(a,b){let c=Date.now(),[d,e]=this.parseToolName(a);if(!d||!e)return{success:!1,error:`Invalid tool name format: ${a}. Expected format: serverId.toolName`,executionTime:Date.now()-c,serverId:d||"unknown",toolName:e||a};let f=this.connections.get(d);if(!f)return{success:!1,error:`Server "${d}" not found`,executionTime:Date.now()-c,serverId:d,toolName:e};if("connected"!==f.status)return{success:!1,error:`Server "${d}" is not connected (status: ${f.status})`,executionTime:Date.now()-c,serverId:d,toolName:e};console.log(`Executing tool "${e}" on server ${d} with parameters:`,b);try{let a=new Promise((a,b)=>{setTimeout(()=>{b(Error(`Tool execution timeout after ${f.config.timeout||3e4}ms`))},f.config.timeout||3e4)}),g=await Promise.race([f.client.callTool({name:e,arguments:b}),a]),h=Date.now()-c;return console.log(`Tool "${e}" executed successfully in ${h}ms`),{success:!0,result:g,executionTime:h,serverId:d,toolName:e}}catch(f){let a=Date.now()-c,b=f instanceof Error?f.message:"Unknown error";return console.error(`Tool execution failed for "${e}" on ${d}:`,b),this.isConnectionError(f)&&(console.log(`Connection error detected, scheduling reconnection for ${d}`),this.scheduleReconnection(d)),{success:!1,error:b,executionTime:a,serverId:d,toolName:e}}}getConnectionStatuses(){let a={};for(let[b,c]of this.connections.entries()){let d=c.connectionStartTime?Date.now()-c.connectionStartTime.getTime():void 0;a[b]={serverId:b,status:this.getHealthStatus(c),lastCheck:c.lastHealthCheck||new Date,error:c.lastError,toolCount:c.tools.length,uptime:d}}return a}async updateServerConfigs(a){console.log(`Updating server configurations for ${a.length} servers`);let b=new Map(a.map(a=>[a.id,a]));for(let[a,c]of this.connections.entries()){let c=b.get(a);c&&c.enabled||(await this.disconnectServer(a),c||this.connections.delete(a))}let c=a.filter(a=>a.enabled).map(async a=>{let b=this.connections.get(a.id);b?this.hasConfigChanged(b.config,a)&&(console.log(`Configuration changed for ${a.name}, reconnecting...`),await this.reconnectServer(a.id)):await this.connectServer(a)});await Promise.allSettled(c)}async performHealthCheck(){if(this.isShuttingDown)return;let a=Array.from(this.connections.values()).filter(a=>"connected"===a.status).map(async a=>{try{let b=Date.now();await a.client.listTools();let c=Date.now()-b;if(a.lastHealthCheck=new Date,!this.isCacheValid(this.toolCache.get(a.id)?.timestamp)){let b=await this.discoverTools(a.client,a.id);a.tools=b,this.toolCache.set(a.id,{tools:b,timestamp:new Date})}console.log(`Health check passed for ${a.config.name} (${c}ms)`)}catch(b){console.error(`Health check failed for ${a.config.name}:`,b),this.isConnectionError(b)&&(a.status="error",a.lastError=b instanceof Error?b.message:"Health check failed",this.scheduleReconnection(a.id))}});await Promise.allSettled(a)}async shutdown(){for(let a of(console.log("Shutting down MCP Client Manager..."),this.isShuttingDown=!0,this.healthCheckTimer&&(clearTimeout(this.healthCheckTimer),this.healthCheckTimer=void 0),this.reconnectTimers.values()))clearTimeout(a);this.reconnectTimers.clear();let a=Array.from(this.connections.keys()).map(a=>this.disconnectServer(a));await Promise.allSettled(a),this.connections.clear(),this.toolCache.clear(),console.log("MCP Client Manager shutdown complete")}startHealthMonitoring(){let a=async()=>{try{await this.performHealthCheck()}catch(a){console.error("Health check error:",a)}finally{this.isShuttingDown||(this.healthCheckTimer=setTimeout(a,this.options.healthCheckInterval))}};this.healthCheckTimer=setTimeout(a,this.options.healthCheckInterval)}async handleConfigurationChange(){if(!this.isShuttingDown)try{console.log("Configuration changed, updating server connections...");let a=await f.EZ.getConfig(),b=Object.entries(a.mcpServers).map(([a,b])=>({id:a,name:a,command:b.command,args:b.args||[],env:b.env||{},enabled:!b.disabled,timeout:b.timeout,maxConcurrency:b.maxConcurrency}));await this.updateServerConfigs(b)}catch(a){console.error("Failed to handle configuration change:",a)}}setupConnectionErrorHandling(a){}scheduleReconnection(a){let b=this.connections.get(a);if(!b||!b.config.enabled||this.isShuttingDown)return;if(b.reconnectAttempts>=this.options.maxReconnectAttempts){console.log(`Max reconnection attempts (${this.options.maxReconnectAttempts}) reached for ${b.config.name}`),b.status="error",b.lastError="Max reconnection attempts exceeded";return}let c=this.reconnectTimers.get(a);c&&clearTimeout(c);let d=this.options.reconnectDelay*Math.pow(2,b.reconnectAttempts);console.log(`Scheduling reconnection for ${b.config.name} in ${d}ms (attempt ${b.reconnectAttempts+1}/${this.options.maxReconnectAttempts})`);let e=setTimeout(async()=>{if(!this.isShuttingDown){b.reconnectAttempts++,b.lastReconnectTime=new Date;try{await this.connectServer(b.config)}catch(c){console.error(`Reconnection failed for ${b.config.name}:`,c),b.reconnectAttempts<this.options.maxReconnectAttempts&&this.scheduleReconnection(a)}}},d);this.reconnectTimers.set(a,e)}parseToolName(a){let b=a.split(".");return b.length<2?[null,null]:[b[0],b.slice(1).join(".")]}isConnectionError(a){if(!a)return!1;let b=a.message?.toLowerCase()||"";return b.includes("connection")||b.includes("timeout")||b.includes("econnrefused")||b.includes("enotfound")||b.includes("closed")||b.includes("broken pipe")||b.includes("socket")}hasConfigChanged(a,b){return a.command!==b.command||JSON.stringify(a.args)!==JSON.stringify(b.args)||JSON.stringify(a.env)!==JSON.stringify(b.env)||a.enabled!==b.enabled||a.timeout!==b.timeout||a.maxConcurrency!==b.maxConcurrency}getHealthStatus(a){return"connected"!==a.status?"unhealthy":a.lastHealthCheck?Date.now()-a.lastHealthCheck.getTime()>2*this.options.healthCheckInterval?"unknown":"healthy":"unknown"}isCacheValid(a){return!!a&&Date.now()-a.getTime()<this.options.toolCacheTimeout}categorizeToolByName(a){let b=a.toLowerCase();return b.includes("file")||b.includes("read")||b.includes("write")?"filesystem":b.includes("web")||b.includes("http")||b.includes("url")?"web":b.includes("search")||b.includes("query")?"search":b.includes("git")||b.includes("repo")?"version-control":"general"}isToolDangerous(a,b){let c=`${a} ${b||""}`.toLowerCase();return["delete","remove","destroy","kill","terminate","format","wipe","clear","reset","drop","execute","run","shell","command","script"].some(a=>c.includes(a))}}let h=null;function i(){return h||(h=new g),h}},64077:(a,b,c)=>{c.d(b,{EZ:()=>n});var d=c(72289),e=c(35282),f=c(79748),g=c.n(f),h=c(29021),i=c(33873),j=c.n(i);let k=d.Ik({command:d.Yj().min(1,"Command is required"),args:d.YO(d.Yj()).optional().default([]),env:d.g1(d.Yj(),d.Yj()).optional().default({}),disabled:d.zM().optional().default(!1),timeout:d.ai().positive().optional().default(3e4),maxConcurrency:d.ai().positive().optional().default(5)}),l=d.Ik({mcpServers:d.g1(d.Yj(),k)});class m{constructor(){this.config=null,this.watchers=new Set,this.fileWatcher=null,this.configPath=j().join(process.cwd(),"config","mcp.config.json")}static getInstance(){return m.instance||(m.instance=new m),m.instance}async loadConfig(){try{let a=await g().readFile(this.configPath,"utf-8"),b=JSON.parse(a),c=l.parse(b);return this.config=c,console.log(`MCP configuration loaded successfully from ${this.configPath}`),c}catch(a){if(a instanceof e.G)throw console.error("MCP configuration validation failed:",a.errors),Error(`Invalid MCP configuration: ${a.errors.map(a=>`${a.path.join(".")}: ${a.message}`).join(", ")}`);if("ENOENT"===a.code)throw console.error(`MCP configuration file not found: ${this.configPath}`),Error(`MCP configuration file not found: ${this.configPath}`);throw console.error("Failed to load MCP configuration:",a),Error(`Failed to load MCP configuration: ${a instanceof Error?a.message:"Unknown error"}`)}}async getConfig(){return this.config||await this.loadConfig(),this.config}async getServerConfig(a){return(await this.getConfig()).mcpServers[a]||null}async getEnabledServers(){let a=await this.getConfig(),b={};for(let[c,d]of Object.entries(a.mcpServers))d.disabled||(b[c]=d);return b}validateConfig(a){return l.parse(a)}async saveConfig(a){try{let b=l.parse(a),c=j().dirname(this.configPath);await g().mkdir(c,{recursive:!0}),await g().writeFile(this.configPath,JSON.stringify(b,null,2),"utf-8"),this.config=b,console.log(`MCP configuration saved to ${this.configPath}`),this.notifyWatchers()}catch(a){throw console.error("Failed to save MCP configuration:",a),Error(`Failed to save MCP configuration: ${a instanceof Error?a.message:"Unknown error"}`)}}startWatching(){if(!this.fileWatcher)try{this.fileWatcher=(0,h.watch)(this.configPath,{persistent:!1},async a=>{if("change"===a){console.log("MCP configuration file changed, reloading...");try{await this.loadConfig(),this.notifyWatchers()}catch(a){console.error("Failed to reload MCP configuration:",a)}}}),console.log(`Started watching MCP configuration file: ${this.configPath}`)}catch(a){console.error("Failed to start watching MCP configuration file:",a)}}stopWatching(){this.fileWatcher&&(this.fileWatcher.close(),this.fileWatcher=null,console.log("Stopped watching MCP configuration file"))}addWatcher(a){this.watchers.add(a)}removeWatcher(a){this.watchers.delete(a)}notifyWatchers(){for(let a of this.watchers)try{a()}catch(a){console.error("Error in MCP configuration watcher:",a)}}async reloadConfig(){return await this.loadConfig()}async configExists(){try{return await g().access(this.configPath),!0}catch{return!1}}async createDefaultConfig(){await this.configExists()||(await this.saveConfig({mcpServers:{filesystem:{command:"npx",args:["-y","@modelcontextprotocol/server-filesystem","/tmp"],env:{},disabled:!1,timeout:3e4,maxConcurrency:5}}}),console.log("Created default MCP configuration"))}}let n=m.getInstance()}};